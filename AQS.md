为了实现上述操作，需要下面三个基本组件的相互协作：
同步状态的原子性管理；
线程的阻塞与解除阻塞；
队列的管理；

创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。

同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。


Lock 与  synchronized
1 需要显示获取和释放锁 （与synchronized对比，synchronized可以隐式获得和释放锁），缺少了synchronized的便捷性，拥有了可操作性，并且可中断的获得锁以及超时获得锁等synchronized不具有的特性。

2.synchronized的获得和释放被固化。lock实现更灵活。比如先获得a，再获得b，再释放a，再获得c等操作lock可以很容易实现。synchronized实现起来相对困难。

lock具有的特性

1.可以在没有线程占有锁的情况下，无阻塞的获得锁。

2.获得锁的线程可响应中断，当获得锁的线程被中断信号时，中断异常被抛出，线程中断并释放锁。

3.超时获得锁。在指定时间没有获得锁直接返回。


同步器

同步器面向实现，lock面向使用者。

同步器的设计基于模板方法

我们可以通过如下方法来访问和修改同步状态。
·getState()：获取当前同步状态。
·setState(int newState)：设置当前同步状态。
·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。

独占锁就是在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。

同步队列

同步器依赖内部的同步队列（一个FIFO双向队列）












http://ifeve.com/aqs-2/