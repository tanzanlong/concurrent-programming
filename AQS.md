为了实现上述操作，需要下面三个基本组件的相互协作：
同步状态的原子性管理；
线程的阻塞与解除阻塞；
队列的管理；

创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。

同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。


Lock 与  synchronized
1 需要显示获取和释放锁 （与synchronized对比，synchronized可以隐式获得和释放锁），缺少了synchronized的便捷性，拥有了可操作性，并且可中断的获得锁以及超时获得锁等synchronized不具有的特性。

2.synchronized的获得和释放被固化。lock实现更灵活。比如先获得a，再获得b，再释放a，再获得c等操作lock可以很容易实现。synchronized实现起来相对困难。

lock具有的特性

1.可以在没有线程占有锁的情况下，无阻塞的获得锁。

2.获得锁的线程可响应中断，当获得锁的线程被中断信号时，中断异常被抛出，线程中断并释放锁。

3.超时获得锁。在指定时间没有获得锁直接返回。


同步器

同步器面向实现，lock面向使用者。

同步器的设计基于模板方法

我们可以通过如下方法来访问和修改同步状态。
·getState()：获取当前同步状态。
·setState(int newState)：设置当前同步状态。
·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。

独占锁就是在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。

同步队列

同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当期线程获取同步状态失败时，同步器将当期线程以及等待状态等信息构造成一个节点信息，加入同步队列。同时阻塞当前线程。

同步器包含两个类型引用，首节点和尾节点，当一个线程获得了同步状态，其他线程都进去队尾，所以存在并发问题，需要保证线程安全，因此队列提供了compareAndSetTail原子方法的，需要传递当前线程认为的尾节点和当前节点。

同步器队列是FIFO的规则，首节点线程在释放同步状态时会唤醒后继节点。唤醒线程是获取到同步状态的线程来完成的，只有一个线程能够获取到同步状态，所以不存在线程安全问题。

独占式状态获取与释放，











http://ifeve.com/aqs-2/